# JavaScript

## 1.对象和数据类型之间的关系

### 数据类型分类

1. **基本数据类型（值类型）**：String字符型，Number数值型，Boolean布尔值，Null空值，Undefined未定义。

2. **引用数据类型（引用类型）**：Object对象

**基本数据类型：**

- 基本数据类型的值是直接保存在**栈内存**中，值与值之间是独立存在的，**修改一个不会影响其他的变量**

**对象：**

- 只要不是基本数据类型，就是对象。

- 对象是保存在堆内存中的，没创建一个对象，就会在**堆内存**开辟一个新的空间，**变量保存的就是一个内存地址**

- **修改一个会影响所有其他引用的此对象的值**

### 注意

实际开发中很容易忽略引用类型的特性，对于引用类型的数据，赋值相当于地址拷贝，a、b指向了同一个堆内存地址。所以改了b，a也会变；本质上a、b就是一个东西。

如果想独立开引用类型的数据，互不影响。可以使用Object.assign()来复制对象

```js
let obj1 = { num: 123 }
let obj2 = Object.assign({}, obj1)
```



## 2.作用域

### 作用域概念

- 通俗讲是变量或函数的`作用范围`，作用域在`函数定义时`，就已经确定了

### 目的

- 为了提高程序的`可靠性`，减少`命名冲突`

### 分类

- `全局作用域`：作用域script标签中，或作用于一个js文件

- `函数作用域（局部作用域）`：作用于函数内部的代码环境

### 全局作用域和`windows对象`

直接写在script标签中的js代码，都属于全局作用域。全局作用域在页面打开时创建，关闭时销毁。

在全局作用域中有一个`全局对象windows`,他代表浏览器的窗口，由浏览器创造，可以直接使用

- 创建的`变量`都会自动保存在windows对象中的`属性`，比如全局作用域有一个`var num = 100`，`num`等同于`windows.num`

- 创建的`函数`会保存在windows对象中的`方法`

### 作用域访问关系

- `内部作用域`可以访问外部作用域
- `外部作用域`无法访问内部作用域

注意：函数作用域在函数定义的时候就已经确定了，所以在其他函数中调用该函数，作用域不变

​	举例：

```js
var a = 1;
function foo() {
    var b = 2;
    console.log(a); //打印结果：1
}
foo();
console.log(b); // 打印结果：Uncaught ReferenceError: b is not defined 没有定义，无法访问内部作用域的变量
```

### 变量的作用域

**全局变量：**

- 在全局作用域下声明的变量，叫`全局变量`。在全局作用域的任何一个地方，都可以访问
- 特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。

**局部变量：**

- 定义在函数作用域的变量，叫`局部变量`。仅限函数内部访问这个变量。
- 函数的`形参`也是属于局部变量。

**执行效率：**

- `全局变量`：只有在浏览器关闭的时候才销毁，比较`占用内存`
- `局部变量`：当其所在的函数执行完毕后销毁，`节省内存`

### 作用域的上下级关系

当一个函数要使用一个变量时，会现在自身作用域寻找（就近原则），如果没有，则会向上一级作用域中寻找，直到最后找到全局作用域，依然没有则报错`ReferenceError`

函数想直接访问`全局作用域`的变量和函数直接可以使用`windows对象`

### 作用域预处理-变量提升

`作用域预处理`的概念：浏览器解析js代码时，会进行一个操作`预处理(预解析)`：将当前js代码中所有变量和函数的定义，放到`当前作用域`代码的最前方

这种预解析也称为`声明提前（变量提升）`

使用`var`关键字声明的变量，会在所有代码执行之前被`声明`（但不会`赋值`），如果不用关键字`var`则不会声明提前（比如使用`let`或`a = 123`直接赋值）

**范例1：**

```js
console.log(a)
var a = 123 // 打印 undefined
```

打印结果不会报错，而是`undefined`，说明`a`被`声明提前了`

**范例2：**

```js
console.log(a)
let a = 123 // 打印 undefined
```

打印结果会报错：`Uncaught ReferenceError: a is not defined`

**范例3：**

```js
foo()
function foo() {
    if(false) {
		var a = 1
    }
    console.log(a) // 打印 undefined
} 
```

打印`undefined` 表示变量`a`在函数执行之前就被`提前声明`了，只是尚未被`赋值`

### 函数的声明提前

不仅在`var`的变量中，使用function创建的函数也会被提前声明，会在所有的代码执行前被创建完成，可以先调用函数，再定义函数

**举例：**

```js
foo() //可以调用函数
function foo() {
    console.log(123) 
}
```

**注意：**

使用`函数表达式`创建的`函数`不会被`声明提前`因为调用该变量时，还是`undefined`

```js
fn(); // 会报错：Uncaught TypeError: fn is not a functio

console.log(fn); // 会打印 undefined

var fn = function foo() {
  console.log(123);
}
```

定义`形参`就相当于在函数作用域中提前声明了变量:

```js
foo(); // 打印 undefined
function foo(e) {
  console.log(e); 
}
```

### 块级作用域

`{}`为`块级作用域`，例如`if语句`中创建的`变量`，只能在`if语句`中使用

在`ES6前`,JavaScript是没有`块级作用域`的概念的

如`var`在`if`中使用，相当于在`全局作用域`与声明了一个变量，在`if`外还是可以使用，很容易造成`变量污染`

**举例：**

```js
if(true) {
    var a = 123
    console.log(a) // 打印 123
}
console.log(a) // 依然可以打印 123
```

在`ES6`中加入了`块级作用域`的`概念`

在块级作用域使用`let`或`const`声明的`变量`将只能在`当前块级作用域使用`,会报错`Uncaught ReferenceError: a is not defined`

**举例**

```js
if (true) {
  let a = 123;
  console.log(a); // 打印 123
}
console.log(a); // 打印 Uncaught ReferenceError: a is not defined
```

## 3.预编译

### JavaScript运行三部曲

脚本执行js引擎都做了什么呢？

1. 语法分析
2. 预编译
3. 解释执行

预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数，预编译确确实实在script代码内执行前发生了
但是它大部分会**发生在函数执行前**

### 预编译流程

```js
<script>
    var a = 1;// 变量声明
    function b(y){//函数声明
        var x = 1;
        console.log('so easy');
    };
    var c = function(){//是变量声明而不是函数声明！！
        //...
    }
    b(100);
</script>

<script>
    var d = 0;
</script>
```

看看引擎对上述代码做了什么吧

- 页面产生便创建了GO全局对象（Global Object），也就是windows对象
- 第一个脚本（script标签）文件加载
- 脚本加载完毕，分析语法是否合法
- 开始预编译
  - 查找变量声明，作为GO属性，值赋予undefined
  - 查找函数声明，作为GO属性，值赋予函数体

```js
//伪代码
GO/window = {
    //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略
    a: undefined,
    c: undefined，
    b: function(y){
        var x = 1;
        console.log('so easy');
    }
}
```

- 变量初始化，直到执行到`函数b`

```js
//伪代码
GO/window = {
    //变量随着执行流得到初始化
    a: 1,
    c: function(){
        //...
    },
    b: function(y){
        var x = 1;
        console.log('so easy');
    }
}
```

- 执行到函数b时，又发生了`预编译`
  - 创建AO活动对象（Active Object）
  - 查找形参和变量声明，放到AO中赋予undefined
  - 实参值赋给形参
  - 查找函数声明，值赋予函数体

```js
//伪代码
AO = {
    //创建AO同时，创建了arguments等等属性，此处省略
    y: 100,
    x: undefined
}
```

- 第一个脚本文件执行完成，加载第二个脚本文件
- 第二个脚本文件加载完毕后，进行语法分析
- 语法分析完毕，开始预编译
  - 重复最开始的预编译步骤……

### 总结

**预编译（函数执行前）**

1. 创建AO对象（Active Object）
2. 查找函数的形参和变量声明，形参名和变量作为AO对象的属性，值为undefied
3. 实参赋值给形参
4. 查找函数声明，函数名作为AO对象的属性，值为函数引用（函数本身）

**预编译(脚本代码块script执行前)**

1. 查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined
2. 查找函数声明，函数名作为全局对象的属性，值为函数引用

**注意**

- 函数使用let时会直接报错：`Uncaught SyntaxError: Identifier 'a' has already been declared (at demo.html:14:13)`，因为当前作用域已用let声明，无法在let声明前读取形参和函数声明

## 4.this

**概念：**

解析器每次在调用函数时，会向函数内部传递一个隐含的参数，这个参数就是`this`，`this`指向的是一个对象，这个对象我们称为`函数执行的上下文对象`

**函数内的this指向：**

1. 以函数的形式：`this`的指向永远是`window`
1. 以方法的形式调用：`this`指的是调用该`方法的对象`
1. 以构造函数的形式：`this`指的是该构造函数的`实例对象`
1. 以事件绑定函数的形式调用时，`this` 指向`绑定事件的对象`
1. 使用 call 和 apply 调用时，this 指向指定的那个对象

## 5.闭包

**闭包的概念**：指`有权访问`另外一个`函数作用域`中`变量`的**函数**

```js
function foo() {
    let a = 1
}
console.log(a) // 此时会报错：Uncaught ReferenceError: a is not defined
```

函数外部只能访问`全局变量`，无法访问函数作用域中的`a`变量，所以会报错

**但在有些场景下，我们需要在`函数外部`访问到`函数作用域`内的`局部变量`，那就可以使用闭包**

如果这个作用域可以访问`另一个函数内部的局部变量`，那就产生了`闭包`，那个作用域所在的函数就称为`闭包函数`



代码举例：

```js
function fn1() {
  let num = 0;
  function fn2() {
    console.log(num);
  }
  fn2()
}
fn1(); // 打印 0
```

上方代码，fn2函数访问了fn1函数中的局部变量。此时fn1中就产生了闭包，fn1就称为闭包函数



闭包可用于延伸变量的作用范围，将调用局部变量的函数返回，供其他作用域使用

```js
function fn1() {
  let num = 0 
  return function fn2() {
    num++
    console.log(num);
  }
}
let num = fn1()
num()
```

**注意事项**

- 闭包函数每调用一次，闭包中的变量将单独存一份，而且不会自动销毁，所以滥用会导致网页的性能问题，在IE可导致内存泄漏，

- 闭包的销毁方法：将闭包所处的变量改变

## 6.数组的常见方法

### 数组类型相关方法

| 方法                             | 描述                               | 备注 |
| -------------------------------- | ---------------------------------- | ---- |
| Array.isArray()                  | **判断**是否为数组                 |      |
| toString()                       | 将数组转为**字符串**               |      |
| Array.from(arrayLike)            | 将**伪数组**转为真数组             |      |
| Array.of(value1, value2, value3) | 创建数组：将**一系列值**转换成数组 |      |

### 数组添加与删除

| 方法      | 描述                                                         | 备注           |
| :-------- | :----------------------------------------------------------- | :------------- |
| push()    | 向数组的**最后面**插入一个或多个元素，返回结果为新数组的**长度** | 会改变原数组   |
| pop()     | 删除数组中的**最后一个**元素，返回结果为**被删除的元素**     | 会改变原数组   |
| unshift() | 在数组**最前面**插入一个或多个元素，返回结果为新数组的**长度** | 会改变原数组   |
| shift()   | 删除数组中的**第一个**元素，返回结果为**被删除的元素**       | 会改变原数组   |
| slice()   | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |
| splice()  | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |
| fill()    | 填充数组：用固定的值填充数组，返回结果为**新的数组**         | 会改变原数组   |

### 数组的合并与拆分

| 方法     | 描述                                                 | 备注             |
| :------- | :--------------------------------------------------- | :--------------- |
| concat() | 合并数组：连接两个或多个数组，返回结果为**新的数组** | 不会改变原数组   |
| join()   | 将数组转换为字符串，返回结果为**转换后的字符串**     | 不会改变原数组   |
| split()  | 将字符串按照指定的分隔符，组装为数组                 | 不会改变原字符串 |

### 数组排序

| 方法      | 描述                                                    | 备注         |
| :-------- | :------------------------------------------------------ | :----------- |
| reverse() | 反转数组，返回结果为**反转后的数组**                    | 会改变原数组 |
| sort()    | 对数组的元素,默认按照**Unicode 编码**，从小到大进行排序 | 会改变原数组 |

### 查找元素

| 方法                  | 描述                                                         | 备注                                                     |
| :-------------------- | :----------------------------------------------------------- | :------------------------------------------------------- |
| indexOf(value)        | 从前往后索引，检索一个数组中是否含有指定的元素               |                                                          |
| lastIndexOf(value)    | 从后往前索引，检索一个数组中是否含有指定的元素               |                                                          |
| includes(item)        | 数组中是否包含指定的内容                                     |                                                          |
| find(function())      | 找出**第一个**满足「指定条件返回 true」的元素                |                                                          |
| findIndex(function()) | 找出**第一个**满足「指定条件返回 true」的元素的 index        |                                                          |
| every()               | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true | 全真才为真。要求每一项都返回 true，最终的结果才返回 true |
| some()                | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true     |

### 遍历数组

|           |                                                              |                                                        |
| :-------- | :----------------------------------------------------------- | :----------------------------------------------------- |
| 方法      | 描述                                                         | 备注                                                   |
| for 循环  | 这个大家都懂                                                 |                                                        |
| forEach() | 和 for 循环类似，但需要**兼容 IE8** 以上                     | forEach() 没有返回值。也就是说，它的返回值是 undefined |
| map()     | 对原数组中的每一项进行加工，将组成**新的数组**               | 不会改变原数组                                         |
| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |
| reduce    | 接收一个函数作为累加器，返回值是回调函数累计处理的结果       |                                                        |

## 7.面向对象的编程思想

### 面向过程和面向对象

**面向过程：**先分析好具体步骤，然后按照步骤，一步一步解决问题

- 优点：性能比面向对象高，事后与`硬件紧密联系`的东西
- 缺点：`没有`面向对象`易维护`、`易复用`、`易扩展`

**面向对象：**以对象功能划分问题，而不是步骤

- 优点：`易维护、易扩展、易复用`，由于面向对象有封装、继承、多态性的特性，可以设计出`低耦合`的系统，使系统 更加`灵活`、更加`易于维护`
- 缺点：`性能`比面向过程`底`

### 面向对象的编程思想

对代码和数据进行封装，以对象调用的方式，对外提供统一的接口

### 面向对象的特性

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律。

面向对象的特性如下：

- 封装性
- 继承性
- 多态性

## 8.构造函数

### 概念

`构造函数`是一种特殊的函数，用来`创建和初始化对象`，必须和`new`一起使用

### 构造函数和普通函数的区别

- 构造函数习惯`首字母大写`
- `调用方式`不同：普通函数直接调用，构造函数需要使用new关键字调用
- `this的指向`不同：普通函数指向window，构造函数指向实例对象

### new一个构造函数的执行流程

**new执行时，会做以下四件事：**

（1）开辟内存空间，在空间创建一个新的空对象

（2）让this的指向指向创建的新对象

（3）执行构造函数里的代码

（4）自动返回这个新对象

```js
function Demo(name,age) {
    this.name = name
    this.age = age
}

const user = new Demo('张三',18)

console.log(user); // 此处会打印一个对象 {name:'张三',age:'18'}
```

### 实例成员与静态成员

实例成员：构造函数的this上添加的成员

静态成员：构造函数上添加的成员

```js
function Demo(name, age) {
  // 实例成员
  this.name = name;
  this.age = age;
}
// 静态成员
Demo.hobby = "打游戏";

let p1 = new Demo("张三", 18);

// 静态成员只能通过构造函数调用
console.log(Demo.hobby);
console.log(p1.hobby); // 使用实例调用则会打印undefined
console.log(Demo.age); // 相反通过构造函数调用实例成员也会打印undefin
```

**总结：**

1. 实例成员之能通过实例对象访问
2. 静态成员只能通过构造函数本身访问